## 算法练习2
**https://leetcode.cn/problems/minimum-size-subarray-sum/description/**
- 这是一道滑动窗口的题目
- 首先，从暴力的角度分析：列举所有的组合，并把所有组合里的数都进行累加，列举所有的组合(left，right)->n^2;在每个组合里进行累加->n,所以，总体的时间复杂度为n^3
- 很明显，这肯定不是最优解法，那么里面的优化在哪里？
 1. 没有利用到单调性的特点，因为都是正数，所以有一些组合能明显筛掉。
 2. 累加的时候不用每次都又在新的组合里重新相加，可以用类似前缀和的思想。
- 将暴力解法进行优化完后也就是滑动窗口的整体思路了：
 1. 利用left和right指针同行移动：left先固定，right向右移动并记录和
 2. 判断：匹配到符合要求的就进行更新，然后left向右移动再进行再进行判断，符合题意就再跟新，不符合题意就right继续向右移动。循环······
- 看似要1通过双指针都各自循环一遍，为n^2,但其实，实际来看，left，right只会移动n次且是互相独立的，时间复杂度应该为2*n
```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n=nums.size();
        int sum=0;
        int len=INT_MAX;
        for(int right=0,left=0;right<n;right++)
        {
            sum+=nums[right];
            while(sum>=target)
            {
                len=min(len,right-left+1);
                sum-=nums[left++];
            }
        }
        return len==INT_MAX?0:len;
    }
};
```



**https://leetcode.cn/problems/longest-substring-without-repeating-characters/**
```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len=0;
        int n=s.size();
        int h[200]={0};
        int ret=0;
        for(int left=0,right=0;right<n;right++)
        {
            if(h[s[right]])
            {
                ret=max(len,ret);
                while(s[left]!=s[right])
                {
                    h[s[left]]=0;
                    left++;
                    len--;
                    
                }
                left++;
            }
            else
            {
                len++;
                h[s[right]]=1;
            }
        }
        ret=max(len,ret);
        return ret;
    }
};
```

```
class Solution 
{
public:
 int lengthOfLongestSubstring(string s) 
 {
 int hash[128] = { 0 }; // 使⽤数组来模拟哈希表 
 int left = 0, right = 0, n = s.size();
 int ret = 0;
 while(right < n)
 {
    hash[s[right]]++; // 进⼊窗⼝ 
    while(hash[s[right]] > 1) // 判断 
    hash[s[left++]]--; // 出窗⼝ 
    ret = max(ret, right - left + 1); // 更新结果 
    right++; // 让下⼀个元素进⼊窗⼝ 
    }
    return ret;
    }
};
```
**https://leetcode.cn/problems/max-consecutive-ones-iii/**
```
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n=nums.size();
        int cnt=0;
        int ret=0;
        int left=0;
        int right=0;
        for(;right<n;right++)
        {
            if(nums[right]==0)cnt++;
            while(cnt>k)
            {
               
                if(!nums[left++])cnt--;
            }
             ret=max(ret,right-left+1);//这步检验卡了我很久，我之前把他放在出窗口里，因为我认为刚要出窗口就可以跟新一次，但是，有些都不用进窗口，所以把它放出窗口的循环里是错误的，
        }
        return ret;
    }
};
```
**https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/**
```
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int sum=0;
        for(auto i:nums)
        {
            sum+=i;
        }
        int target=sum-x;
        if(target<0)return -1;//卡这一步了，如果不写这步，下面就会陷入死循环
        //所以，我们在思考的时候，如果想到特殊情况，最好先进行特殊处理来规避掉一些主体核心代码可能的错误
        int ssum=0;
        int n=nums.size();
        int ret=-1;
        for(int left=0,right=0;right<n;right++)
        {
            ssum+=nums[right];
            while(ssum>=target)
            {
                if(ssum==target)
                {
                    ret=max(ret,right-left+1);
                    break;
                }
                ssum-=nums[left++];
            }
        }
        return ret==-1?-1:n-ret;
    }
};
```


**https://leetcode.cn/problems/fruit-into-baskets/**
```class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int ret=0;
        int n=fruits.size();
        int hash[100005]={0};
        int kind=0;
        for(int left=0,right=0;right<n;right++)
        {
            if(!hash[fruits[right]])kind++;
            hash[fruits[right]]++;
            while(kind>2)
            {
                hash[fruits[left]]--;
                if(!hash[fruits[left]])kind--;
                left++;
            }
            ret=max(ret,right-left+1);
        }
        return ret;

    }
};
```
**https://leetcode.cn/problems/find-all-anagrams-in-a-string/**
```
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int hash1[26]={0};
        int hash2[26]={0};
        vector<int>ret;
        for(auto i:p)
        {
            hash1[i-'a']++;
        }
        int n=s.size();
        int num=0;
        for(int left=0,right=0;right<n;right++)
        {
            hash2[s[right]-'a']++;
            if(hash2[s[right]-'a']<=hash1[s[right]-'a'])num++;
            if(right-left+1>p.size())
            {
               if(hash2[s[left]-'a']<=hash1[s[left]-'a'])num--;
                hash2[s[left]-'a']--;
                left++;
            }
            if(num==p.size())ret.push_back(left);
        }
        return ret;
    }
};
```

**https://leetcode.cn/problems/minimum-window-substring/submissions/645802506/**
```
class Solution {
public:
    string minWindow(string s, string t) {
        int hash1[200]={0};
        for(auto i:t)
        {
            hash1[i]++;
        }
        int hash2[200]={0};
        int n=s.size();
        int num=0;
        int ret1=100005;
        int ret2=100005;
        for(int left=0,right=0;right<n;right++)
        {
            hash2[s[right]]++;
            if(hash2[s[right]]<=hash1[s[right]])num++;
            
            while(num==t.size())
            {
                if(num==t.size())
            {
                if(right-left+1<ret1)
                {
                    ret1=right-left+1;
                    ret2=left;
                }
            }
                if(hash2[s[left]]==hash1[s[left]])num--;
                hash2[s[left]]--;
                
                left++;
            }
        }
        if(ret1==100005)return "";
        string ret=s.substr(ret2,ret1);
        return ret;
    }
};
```