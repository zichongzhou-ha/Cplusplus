
**https://www.nowcoder.com/practice/acead2f4c28c401889915da98ecdc6bf?tpId=230&tqId=2021480&ru=/exam/oj&qru=/ta/dynamic-programming/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196**
```
#include <iostream>
#include<vector>
using namespace std;

int main() {
    int n,m;
    cin>>n>>m;
    vector<int>arr(n+1);
    for(int i=1;i<=n;i++)
    {
        cin>>arr[i];
    }
    vector<long long>dp(n+1);
    for(int i=1;i<=n;i++)
    {
        dp[i]=dp[i-1]+arr[i];
    }
    while(m--)
    {
        int l,r;
        cin>>l>>r;
        cout<<dp[r]-dp[l-1]<<endl;
    }
    return 0;
}
```

**https://www.nowcoder.com/practice/99eb8040d116414ea3296467ce81cbbc?tpId=230&tqId=2023819&ru=/exam/oj&qru=/ta/dynamic-programming/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196**

```
#include <iostream>
#include<vector>
using namespace std;

int main() {
    int n,m,q;
    cin>>n>>m>>q;
    vector<vector<int>>arr(n+1,vector<int>(m+1));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>arr[i][j];
        }
    }
    vector<vector<long long>>dp(n+1,vector<long long>(m+1));//又一次死在long long上
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+arr[i][j];
        }
    }
    while(q--)
    {
        int x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
        cout<<dp[x2][y2]+dp[x1-1][y1-1]-dp[x1-1][y2]-dp[x2][y1-1]<<endl;
    }
    return 0;
}
// 64 位输出请用 printf("%lld")
```

**https://leetcode.cn/problems/find-pivot-index/**
```
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int n=nums.size();
        vector<int>f(n);
        vector<int>g(n);
        for(int i=1;i<n;i++)
        {
            f[i]=f[i-1]+nums[i-1];
        }
        for(int j=n-2;j>=0;j--)
        {
            g[j]=g[j+1]+nums[j+1];
        }
        for(int i=0;i<n;i++)
        {
            if(f[i]==g[i])return i;
        }
        return -1;
    }
};
```
**https://leetcode.cn/problems/product-of-array-except-self/**
```
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n=nums.size();
        vector<int>f(n);
        f[0]=1;
        for(int i=1;i<nums.size();i++)
        {
            f[i]=f[i-1]*nums[i-1];
        }
        vector<int>g(n);
        g[n-1]=1;
        for(int i=nums.size()-2;i>=0;i--)
        {
            g[i]=g[i+1]*nums[i+1];
        }
        for(int i=0;i<n;i++)
        {
            nums[i]=f[i]*g[i];
        }
        return nums;
    }
};
```


**https://leetcode.cn/problems/subarray-sum-equals-k/submissions/647290267/**
>警示：看到这道题脑子第一反应竟然是滑动窗口，但是，因为数组中有负数或0，如果用滑动窗口的话可能会忽略掉一些情况
```
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int>hash;
        hash[0]=1;//为啥有这一步，因为在循环中我们可看见，hash[sum]是到最后才进行++操作的，那么，当它就只有自己这么一个元素时，本身也是其中的1
        int sum=0;
        int ret=0;
        for(auto x:nums)
        {
            sum+=x;
            if(hash[sum-k])ret+=hash[sum-k];
            hash[sum]++;
        }
        return ret;
    }
};
```

**https://leetcode.cn/problems/subarray-sums-divisible-by-k/**
- 同余定理：(a-b)/k==0---->a%k=b%k;

- 在算法中，我们遇到a%b时，当a为负数，结果也就为负数了，要想避免这种情况，使得正负统一，用的是(a%b+b)%b

```
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {

        unordered_map<int,int>hash;
        hash[0%k]=1;
        int sum=0;
        int ret=0;
        for(auto x:nums)
        {
            sum+=x;
            int r=(sum%k+k)%k;
            if(hash.count(r)) ret+=hash[r];
            hash[r]++;
        }
        return ret;
    }
};
```

**https://leetcode.cn/problems/contiguous-array/description/**
```
class Solution 
{
public:
    int findMaxLength(vector<int>& nums) 
    {
        unordered_map<int, int> hash;
        hash[0] = -1; // 默认有⼀个前缀和为 0 的情况 
        int sum = 0, ret = 0;
        for(int i = 0; i < nums.size(); i++)
        {
        sum += nums[i] == 0 ? -1 : 1; // 计算当前位置的前缀和 
        if(hash.count(sum)) ret = max(ret, i - hash[sum]);
        else hash[sum] = i;
        }
        return ret;
    }
};

```


**https://leetcode.cn/problems/matrix-block-sum/**

```
class Solution {
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        int m = mat.size();
        int n = mat[0].size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] +
                           mat[i - 1][j - 1];
            }
        }
        vector<vector<int>> ret(m, vector<int>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int x1 = max(0, i - k) + 1;
                int y1 = max(0, j - k) + 1;
                int x2 = min(i + k, m - 1) + 1;
                int y2 = min(j + k, n - 1) + 1;
                ret[i][j] = dp[x2][y2] - dp[x2][y1 - 1] - dp[x1 - 1][y2] +
                            dp[x1 - 1][y1 - 1];
            }
        }
        return ret;
    }
    };
```